--CREATE TABLE

CREATE TABLE dept_TEMP
		AS(SELECT * FROM dept);
		
SELECT *
FROM DEPT_TEMP dt 
;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
	   VALUES(50, 'DATABASE', 'SEOUL');
	   
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
	   VALUES(70, 'WEB', 'NULL');
	   
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
	   VALUES(70, 'WEB', 'NULL');
	  
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
	   VALUES(80, 'MOBILE', '');
	   
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
	   VALUES(90, 'INCHEON');
	   
	  
CREATE TABLE EMP_TEMP
AS SELECT *
FROM EMP
WHERE 1<>1; --데이터는제외 컬럼만 복사
	  
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
	   VALUES(9999, '홍길동','PRESIDENT',NULL,'2001/01/01',5000,1000,10);
	  
	  
INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
	   VALUES(2111, '이순신','MANAGER',9999
	  	     ,TO_DATE('07/01/2001', 'DD/MM/YYYY'), 4000, NULL, 10);
	  
INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
	   VALUES(3111, '심청이','MANAGER',9999
	  	     ,SYSDATE, 4000, NULL, 30);
	  
INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
	   SELECT E.EMPNO , E.ENAME , E.JOB , E.MGR , E.HIREDATE , E.SAL , E.COMM , E.DEPTNO 
	   FROM EMP E, SALGRADE s 
	   WHERE E.SAL  BETWEEN S.LOSAL AND S.HISAL
	   AND S.GRADE = 1;
	  
	  
--UPDATE 문 : 필터된 데이터에 대해서 레코드 값을 수정.
--UPDATE, SET WHERE 가 반드시 필요. WHERE 지정 안하면 모든게 바뀌어버림.
	  
CREATE TABLE DEPT_TEMP2
	   AS (SELECT * FROM DEPT);
	  
SELECT * FROM DEPT_TEMP2;

UPDATE DEPT_TEMP2
	   SET LOC = 'SEOUL'
;
	  
ROLLBACK;
	  
UPDATE DEPT_TEMP2
	SET DNAME = 'DATABASE',
	    LOC = 'SEOUL'
	WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

SELECT *
	FROM DEPT_TEMP2
	WHERE ROWNUM < 3;
	  
	  
UPDATE DEPT_TEMP2
 SET (DNAME,LOC) = (SELECT DNAME, LOC
 					FROM DEPT
 					WHERE DEPTNO = 40)
 WHERE DEPTNO = 40
;
 
	  
UPDATE DEPT_TEMP2 
 SET DNAME = (SELECT DNAME
 			  		FROM DEPT
 			  		WHERE DEPTNO = 40),
 	 LOC = (SELECT LOC
 			  		FROM DEPT
 			  		WHERE DEPTNO = 40)
 WHERE DEPTNO = 40;

--DELETE 구문으로 테이블에서 값을 제거
--보통의 경우, DELETE보다 UPDATE 구문으로 상태값을 변경
--근무/휴직/퇴사 등의 유형으로 값을 변경
--대부분의 경우 WHERE 조건이 필요.

SELECT *
 FROM EMP_TEMP2;

CREATE TABLE EMP_TEMP2
		AS (SELECT * FROM EMP)
;

DELETE FROM EMP_TEMP2
 WHERE JOB = 'MANAGER'
; --인사팀에서 명령 실행 요청.

ROLLBACK; --승인 OR 취소
COMMIT;

--WHERE 조건을 더 복잡하게 주고 DELETE실행

DELETE FROM EMP_TEMP2
 WHERE EMPNO IN (SELECT EMPNO
 				 FROM EMP_TEMP2 E, SALGRADE s 
 				 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
 				 	AND S.GRADE = 3
 				 	AND DEPTNO = 30)
 ;

/*
 * CREATE문을 정의 : 기존에 없는 테이블 구조를 생성
 * 
 * 데이터는 없고, 테이블의 칼럼과 데이터타입, 제약 조건 등의 구조 생성
 * 
 */


CREATE TABLE EMP_NEW(
	 EMPNO 		NUMBER(4)
	,ENAME 		VARCHAR2(10)
	,JOB 		VARCHAR2(9)
	,MGR 		NUMBER(4)
	,HIREDATE 	DATE
	,SAL 		NUMBER(7,2)
	,COMM 		NUMBER(7,2)
	,DEPTNO 	NUMBER(2)
	 );
	
--줄 잘 맞추기
	
SELECT * FROM EMP_NEW;

SELECT *
 FROM EMP
 WHERE rownum <= 5
;
--rownum = 5는 작동이 안돼. 사실상 갯수를 세주는 함수라 보면됨. 특정 행을 가져오려는 목적 아님.

ALTER TABLE EMP_NEW
 ADD HP VARCHAR2(20)
 ;

ALTER TABLE EMP_NEW
 RENAME COLUMN HP TO TEL_NO --잘못된 칼럼명 HP를 TEL_NO로 수정
 ;
	  

--
ALTER TABLE EMP_NEW --새로 인수한 직원 번호 늘림.
 MODIFY EMPNO NUMBER(5)
 ;

ALTER TABLE EMP_NEW
 DROP COLUMN TEL_NO;





--SEQUENCE 일련번호를 생성하여 테이블 관리를 편하게 함.

CREATE SEQUENCE SEQ_DEPTSEQ  --SEQ_DEPTNO라고 적으면 더 직관적.
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 99
	MINVALUE 1
	NOCYCLE NOCACHE
	;

CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
	VALUES(SEQ_DEPTSEQ.NEXTVAL, 'DATABASE','SEOUL');

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
	VALUES(SEQ_DEPTSEQ.NEXTVAL, 'DATABASE1','SEOUL1');

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
	VALUES(SEQ_DEPTSEQ.NEXTVAL, 'DATABASE2','SEOUL2');

SELECT * FROM DEPTSEQ ;


/*
 * 
 * 제약조건 지정
 * 자주 사용되는 중요한 제약조건 유형
 * NOT NULL
 * UNIQUE
 * PK
 * FK
 * 
 * 
 */



CREATE TABLE LOGIN(
	 LOGIN_ID		VARCHAR2(20) NOT NULL
	,LOGIN_PWD		VARCHAR2(20) NOT NULL
	,TEN			VARCHAR2(20)
	)

ALTER TABLE LOGIN
 RENAME COLUMN TEN TO TEL;
	
INSERT INTO LOGIN(LOGIN_ID, LOGIN_PWD, TEL)
	VALUES('TEST_ID01', NULL, '010-1234-1234')
	;

INSERT INTO LOGIN(LOGIN_ID, LOGIN_PWD)
	VALUES('TEST_ID01', '1234')
	;

SELECT * FROM LOGIN;

UPDATE LOGIN
 SET LOGIN_PWD = NULL
 WHERE LOGIN_ID = 'TEST_ID01'
;

ALTER TABLE LOGIN
 MODIFY (TEL NOT NULL); --NULL 값이 존재해서 제약조건 설정 불가능

UPDATE LOGIN
 SET TEL = '010-2324-2234'
 WHERE LOGIN_ID = 'TEST_ID01';

ALTER TABLE LOGIN
 MODIFY (TEL NOT NULL);--NULL 값이 없어져서 변경 가능

	  
CREATE TABLE LOGIN2(
	 LOGIN_ID		VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN  NOT NULL
	,LOGIN_PWD		VARCHAR2(20) CONSTRAINT TBLNN2_LGNPWD_NN NOT NULL
	,TEL 			VARCHAR2(20)
	);
 
 SELECT OWNER
 	   ,CONSTRAINT_NAME
 	   ,CONSTRAINT_TYPE
 	   ,TABLE_NAME
 FROM USER_CONSTRAINTS
 ;
 
 
 
ALTER TABLE LOGIN2
 MODIFY (TEL CONSTRAINT TBLNN_TEL_NN NOT NULL)
 ;
 
SELECT OWNER
	  ,CONSTRAINT_NAME
	  ,CONSTRAINT_TYPE
	  ,TABLE_NAME
 FROM USER_CONSTRAINTS 
  WHERE TABLE_NAME = 'LOGIN2'
  ;
 
 ALTER TABLE LOGIN2
  DROP CONSTRAINT TBLNN_TEL_NN
  ;
 
 CREATE TABLE LOGIN_UNIQUE(
	 LOGIN_ID		VARCHAR2(20) UNIQUE
	,LOGIN_PWD		VARCHAR2(20) NOT NULL
	,TEL 			VARCHAR2(20)
	);
 
 SELECT OWNER
	  ,CONSTRAINT_NAME
	  ,CONSTRAINT_TYPE
	  ,TABLE_NAME
 FROM USER_CONSTRAINTS 
  WHERE TABLE_NAME = 'LOGIN_UNIQUE'
  ;
 
 INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) 
 	VALUES('TEST_ID01', 'PWD01', '010-1231-1231')
 	;
 INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) 
 	VALUES('TEST_ID02', 'PWD02', '010-1231-1231')
 	;  
 INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) 
 	VALUES(NULL, 'PWD01', '010-1231-1231')
 	;  
  
SELECT * FROM LOGIN_UNIQUE;

UPDATE LOGIN_UNIQUE 
 SET LOGIN_ID = 'TEST_ID_NEW'
 WHERE LOGIN_ID IS NULL;-- =NULL로 하면 작동 안함.

COMMIT;

  
--PK(주키) 테이블을 설명하는 가장 중요한 키
--NOT NULL, UNIQUE, INDEX

 CREATE TABLE TABLE_PK(
	 LOGIN_ID		VARCHAR2(20) PRIMARY KEY
	,LOGIN_PWD		VARCHAR2(20) NOT NULL
	,TEL 			VARCHAR2(20)
	);
  
  
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME
 FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'TABLE_PK%'
 ;

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
	VALUES('PK01', 'PW01', '0102222')
	;
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
	VALUES(NULL, 'PW01', '0102222')
	;
INSERT INTO TABLE_PK(LOGIN_PWD, TEL)
	VALUES('PW01', '0102222')
	;  
  
 
SELECT * FROM TABLE_PK;



--존재하지 않는 부서 번호를 EMP_TEMP 테이블에 입력을 시도

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
	VALUES(2333, 'GHOST', 'CLERK', '7788', '2017/04/30', 120, NULL, 90);

SELECT * FROM EMP_TEMP

--존재하지 않는 부서 번호를 EMP 테이블에 입력을 시도 -> FK 제약조건이 있어서 안들어가. DEPT를 참조하는데 90이 없음.

INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
	VALUES(2333, 'GHOST', 'CLERK', '7788', '2017/04/30', 120, NULL, 90);

SELECT * FROM EMP;



--INDEX 빠른 검색을 위한 색인
--장점 : 원하는 값을 빠르게 찾아준다.
--단점 : 입력과 출력이 잦은 경우, 인덱스가 설정된 테이블의 속도가 저하된다.


--특정 직군에 해당하는 직원을 빠르게 찾기 위한 색인 지정.
CREATE INDEX IDX_EMP_JOB
	ON EMP(JOB)
	;

SELECT * 				--인덱스 정보 확인
 FROM USER_INDEXES
 WHERE TABLE_NAME IN ('EMP', 'DEPT')
 ;
	  
SELECT * 
 FROM USER_IND_COLUMNS
 WHERE TABLE_NAME IN ('EMP', 'DEPT')
 ;	  

--가상의 임시 테이블

CREATE VIEW VW_EMP
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
			FROM EMP WHERE DEPTNO = 10)
 ;
			
CREATE VIEW VW_EMP20
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
			FROM EMP WHERE DEPTNO = 20)
 ;

SELECT * 
 FROM USER_VIEWS
 --WHERE VIEW_NAME = 'VM_EMP';

SELECT VIEW_NAME, TEXT_LENGTH, TEXT FROM USER_VIEWS;

--여기서는 VIEW의 사용이 TABLE에서와 비슷하다.(247P)


--ROWNUM 상위 N개 출력.
SELECT ROWNUM
	 , E.*
FROM EMP E
ORDER BY SAL DESC;
 --EMP테이블에서 가져오는 순서로 순번을 출력. SAL DESC 순서와는 무관함.

SELECT ROWNUM
	 , E.*
 FROM (SELECT *
 			FROM EMP E
 			ORDER BY SAL DESC) E; --인라인뷰에 E 별칭.
 --SAL의 내림차순 순서에 따라 ROWNUM을 부여하여 출력.
 			
 			
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
SELECT ROWNUM
	  ,E.*
FROM E;

SELECT ROWNUM
	  ,E.*
 FROM (SELECT *
 		FROM EMP E
 		ORDER BY SAL DESC) E
 WHERE ROWNUM <= 5;


--오라클 객체에 대한 정보 제공 목적
SELECT * FROM DICT;

SELECT * FROM DICT WHERE TABLE_NAME LIKE 'USER_CON%' --와일드카드는 =말고 LIKE로 사용함.

SELECT TABLE_NAME
FROM USER_TABLES;

SELECT OWNER, TABLE_NAME
 FROM ALL_TABLES;

SELECT * FROM V$VERSION;
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_USERS
 WHERE USERNAME = 'SCOTT';













































